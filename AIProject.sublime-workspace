{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"current",
				"current_team"
			],
			[
				"make",
				"make_tuple"
			],
			[
				"are",
				"areFree"
			],
			[
				"cast",
				"castle_row"
			],
			[
				"BORD",
				"BORDER_DEPTH"
			],
			[
				"genera",
				"generate_valid_moves"
			],
			[
				"Piece",
				"PieceListBlack"
			],
			[
				"valid",
				"valid_moves"
			],
			[
				"is",
				"isInCheck"
			],
			[
				"curre",
				"current_team"
			],
			[
				"PieceList",
				"PieceListBlack"
			],
			[
				"er",
				"EraseFun"
			],
			[
				"piece",
				"pieceArray"
			],
			[
				"b",
				"b"
			],
			[
				"H",
				"H"
			],
			[
				"PLAY",
				"CHESS_PLAY_LENGTH"
			],
			[
				"board",
				"board_state"
			],
			[
				"boar",
				"board_state"
			],
			[
				"col",
				"col1Check"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/header/chess_board.h",
			"settings":
			{
				"buffer_size": 1919,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/header/piece.h",
			"settings":
			{
				"buffer_size": 1159,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/main.cpp",
			"settings":
			{
				"buffer_size": 505,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#include \"chess_board.h\"\n\nusing namespace std;\n\nvoid ChessBoard::initColCharToNum() {\n	colCharToNum['a'] = 0;\n	colCharToNum['b'] = 1;\n	colCharToNum['c'] = 2;\n	colCharToNum['d'] = 3;\n	colCharToNum['e'] = 4;\n	colCharToNum['f'] = 5;\n	colCharToNum['g'] = 6;\n	colCharToNum['h'] = 7;\n}\n\nbool ChessBoard::isInCheck() {\n	bool isInCheck = false;\n	// Find king\n	if (this->current_team == WHITE)\n		for (auto p : PieceListBlack) {\n			isInCheck |= p->threatens_king();\n		}\n	else\n		for (auto p : PieceListWhite) {\n			isInCheck |= p->threatens_king();\n		}\n	return isInCheck;\n	// Check to see if you run into pieces in any direction, \n}\n\nbool ChessBoard::is_move_valid\n\n/* Return codes - \n-2 - Can't make that move while King is in check\n-1 - to is not valid\n0 - There is no piece at from\n1 - ok move \n3 - ok, a king is now in check \n4 - ok, player that moved has won\n*/\nChessBoard* ChessBoard::makeMove(MoveType move_type, std::pair<int,int> from, std::pair<int,int> to, bool is_valid) {\n\n	// Validate move\n	if (!is_valid) {\n		for (auto m : valid_moves) {\n			auto mt = std::get<0>(m);\n			auto mfrom = std::get<1>(m);\n			auto mto = std::get<2>(m);\n			if (mt == move_type &&\n				std::get<0>(mfrom) == std::get<0>(from) && std::get<1>(mfrom) == std::get<1>(from) &&\n				std::get<0>(mto) == std::get<0>(to) && std::get<1>(mto) == std::get<1>(to) ) {\n				is_valid = true;\n			}\n		}\n\n		if (!is_valid)\n			return -1;\n	}\n\n	// Construct a new board\n\n	auto next_team = current_team == WHITE ? BLACK : WHITE;\n\n\n\n	return new ChessBoard();\n}\n\nvoid ChessBoard::newPiece(Piece::PlayerPiece player_piece, int row, int col, Teams team) {\n	board_state[row][col] = player_piece;\n	pieceArray[row][col] = new Piece(player_piece, row, col);\n	if (team == WHITE)\n		PieceListWhite.push_back(pieceArray[row][col]);\n	else\n		PieceListBlack.push_back(pieceArray[row][col]);\n}\n\nvoid ChessBoard::removePiece(int row, int col) {\n	Teams team = (Teams)pieceArray[row][col]->get_team();\n	board_state[row][col] = Piece::Types::NONE;\n	auto EraseFun = [row, col](Piece* this_piece) \n				{\n					auto coords = this_piece->get_coords(); \n					return std::get<0>(coords) == row \n							&& std::get<1>(coords) == col;\n				};\n	if (team == WHITE) {\n		PieceListWhite.erase(\n			std::remove_if(\n				PieceListWhite.begin(), \n				PieceListWhite.end(), \n				EraseFun),\n			PieceListWhite.end());\n	} else {\n		PieceListBlack.erase(\n			std::remove_if(\n				PieceListBlack.begin(), \n				PieceListBlack.end(), \n				EraseFun),\n			PieceListBlack.end());\n	}\n	delete pieceArray[row][col];\n}\n\nvoid ChessBoard::placePieces() {\n	// Add pieces to the chess board\n	// Note: White starts up top, Black starts on the buttom\n\n	// First add White pieces\n	// King is first\n	newPiece(Piece::WHITE_KING, BORDER_DEPTH, BORDER_DEPTH + CHESS_PLAY_LENGTH-4, WHITE);\n\n	// White Pawns:\n	for (int i = 0; i < CHESS_PLAY_LENGTH; i++) {\n		newPiece(Piece::WHITE_PAWN, 1+BORDER_DEPTH, i+BORDER_DEPTH, WHITE);\n	}\n\n	//White Rooks\n	newPiece(Piece::WHITE_ROOK, BORDER_DEPTH, BORDER_DEPTH, WHITE);\n	newPiece(Piece::WHITE_ROOK, BORDER_DEPTH, BORDER_DEPTH + CHESS_PLAY_LENGTH-1, WHITE);\n	//White Knights\n	newPiece(Piece::WHITE_KNIGHT, BORDER_DEPTH, BORDER_DEPTH+1, WHITE);\n	newPiece(Piece::WHITE_KNIGHT, BORDER_DEPTH, BORDER_DEPTH + CHESS_PLAY_LENGTH-2, WHITE);\n\n	//White Bishops\n	newPiece(Piece::WHITE_BISHOP, BORDER_DEPTH, BORDER_DEPTH+2, WHITE);\n	newPiece(Piece::WHITE_BISHOP, BORDER_DEPTH, BORDER_DEPTH + CHESS_PLAY_LENGTH-3, WHITE);\n\n	//White King\n	newPiece(Piece::WHITE_QUEEN, BORDER_DEPTH, BORDER_DEPTH+3, WHITE);\n	//White Queen\n\n	//Now add Black pieces\n\n	// King is first, at front of vector\n	newPiece(Piece::BLACK_KING, BOARD_LENGTH-BORDER_DEPTH-1, BORDER_DEPTH + CHESS_PLAY_LENGTH-4, BLACK);\n\n	// Black Pawns:\n	for (int i = 0; i < CHESS_PLAY_LENGTH; i++) {\n		newPiece(Piece::BLACK_PAWN, BOARD_LENGTH-BORDER_DEPTH-2, i+BORDER_DEPTH, BLACK);\n	}\n\n	//Black Rooks\n	newPiece(Piece::BLACK_ROOK, BOARD_LENGTH-BORDER_DEPTH-1, BORDER_DEPTH, BLACK);\n	newPiece(Piece::BLACK_ROOK, BOARD_LENGTH-BORDER_DEPTH-1, BORDER_DEPTH + CHESS_PLAY_LENGTH-1, BLACK);\n	//Black Knights\n	newPiece(Piece::BLACK_KNIGHT, BOARD_LENGTH-BORDER_DEPTH-1, BORDER_DEPTH+1, BLACK);\n	newPiece(Piece::BLACK_KNIGHT, BOARD_LENGTH-BORDER_DEPTH-1, BORDER_DEPTH + CHESS_PLAY_LENGTH-2, BLACK);\n\n	//Black Bishops\n	newPiece(Piece::BLACK_BISHOP, BOARD_LENGTH-BORDER_DEPTH-1, BORDER_DEPTH+2, BLACK);\n	newPiece(Piece::BLACK_BISHOP, BOARD_LENGTH-BORDER_DEPTH-1, BORDER_DEPTH + CHESS_PLAY_LENGTH-3, BLACK);\n\n	//Black King\n	newPiece(Piece::BLACK_QUEEN, BOARD_LENGTH-BORDER_DEPTH-1, BORDER_DEPTH+3, BLACK);\n	//Black Queen\n\n	// Generate opposing pieces' moves.\n	for (auto p : PieceListBlack) {\n		p->generate_valid_moves(board_state);\n	}\n	for (auto p : PieceListWhite) {\n		p->generate_valid_moves(board_state);\n	}\n\n\n}\n\nvoid ChessBoard::generate_moves() {\n	// Only generate moves for the current team\n	std::vector<Piece*>* useVector = this->current_team == WHITE ? &PieceListWhite : &PieceListBlack;\n	int castle_row = this->current_team == WHITE ? BORDER_DEPTH : BOARD_LENGTH - BORDER_DEPTH - 1;\n\n	// Note - if in check, only the king counts. Otherwise, everything does\n	if (isInCheck()) {\n		auto king = useVector->front();\n		for (auto move : king->get_valid_moves()) {\n			auto move_tuple = std::make_tuple(MOVE, king->get_coords(), move);\n			valid_moves.push_back(move_tuple);\n		}\n	} else {\n		// Generate move sets for each piece, add them to the actual valid move list\n		for (std::vector<Piece*>::iterator p = useVector->begin(); p < useVector->end(); ++p) {\n			(*p)->generate_valid_moves(board_state);\n			for (auto move : (*p)->get_valid_moves()) {\n				auto move_tuple = std::make_tuple(MOVE, (*p)->get_coords(), move);\n				valid_moves.push_back(move_tuple);\n			}\n		}\n	}\n\n	// Add in Castling moves\n	// 6 different conditions\n\n	auto king = useVector->front();\n    \n	// Check if king was moved and King not in check\n	if (!isInCheck() && king->get_has_moved() == false) {\n		// Rook Left\n		auto rook = pieceArray[a][castle_row];\n		if (rook != NULL && \n			rook ->get_has_moved() == false &&\n			rook->typeOf() == Piece::Types::ROOK) {\n			// Check if the intervening spaces are free\n			bool areFree = true;\n			for (int i = std::get<1>(king->get_coords()) - 1; i > a; i--) {\n				if (board_state[a][b] != Piece::Types::NONE) {\n					areFree = false;\n				}\n			}\n			if (areFree) {\n				auto move = std::make_tuple(CASTLE, king->get_coords(), rook->get_coords());\n				valid_moves.push_back(move);\n			}\n		}\n		// Rook Right\n		rook = pieceArray[h][castle_row];\n		if (rook != NULL && \n			rook ->get_has_moved() == false &&\n			rook->typeOf() == Piece::Types::ROOK) {\n			// Check if the intervening spaces are free\n			bool areFree = true;\n			for (int i = std::get<1>(king->get_coords()) - 1; i < h; i++) {\n				if (board_state[a][b] != Piece::Types::NONE) {\n					areFree = false;\n				}\n			}\n			if (areFree) {\n				auto move = std::make_tuple(CASTLE, king->get_coords(), rook->get_coords());\n				valid_moves.push_back(move);\n			}\n		}\n\n	}\n\n	// Rook 1:\n	// Was the rook moved?\n\n	//Are there pieces in between?\n\n	auto filter_function = [] () {\n		// Make move, determine if king in check\n\n	}\n\n	// Now filter all moves bahttp://preshing.com/20110811/xkcd-password-generator/sed on whether or not the king is in check afterwards (probably the most computationally intensive)\n}\n\n// Creates a new chessboard, set up with the next board state.\nChessBoard::ChessBoard(int board_state[][BOARD_LENGTH], \n	std::vector<Piece*> PieceListWhite, \n	std::vector<Piece*> PieceListBlack, \n	Piece* pieceArray[][BOARD_LENGTH]) {\n	initColCharToNum();\n\n	this->PieceListWhite = PieceListWhite;\n	this->PieceListBlack = PieceListBlack;\n	for (int i = 0; i < BOARD_LENGTH; i++) {\n		for (int j = 0; j < BOARD_LENGTH; j++) {\n			this->board_state[i][j] = board_state[i][j];\n			this->pieceArray[i][j] = pieceArray[i][j];\n		}\n	}\n\n}\n\n// Creates a _new_ chessboard, set up with a standard chess start\nChessBoard::ChessBoard() {\n	// Initialize the map colCharToNum\n	initColCharToNum();\n	// First zero out the board (Or set to be invalid)\n	for (int i = 0; i < BOARD_LENGTH; i++) {\n		for (int j = 0; j < BOARD_LENGTH; j++) {\n			// Mark regions that are out of bounds as such\n			if (i < BORDER_DEPTH || \n				j < BORDER_DEPTH || \n				i >= BOARD_LENGTH - BORDER_DEPTH || \n				j >= BOARD_LENGTH - BORDER_DEPTH)\n				board_state[i][j]=Piece::Types::INVALID;\n			else\n				board_state[i][j]=Piece::Types::NONE;\n			pieceArray[i][j] = NULL;\n		}\n	}\n	// Place pieces on chess board\n	placePieces();\n	generate_moves();\n	this->current_team = WHITE;\n}\n\nChessBoard::~ChessBoard() {\n	for (int i = 0; i < BOARD_LENGTH; i++) {\n		for (int j = 0; j < BOARD_LENGTH; j++) {\n			if (pieceArray[i][j] != NULL)\n				delete pieceArray[i][j];\n		}\n	}\n}\n\nvoid ChessBoard::printBoardState() {\n	cout << \"  ----------------------- \" << endl;\n	for (int i = BOARD_LENGTH-BORDER_DEPTH-1; i >= BORDER_DEPTH; i--) {\n		cout << i-1 << \"|\";\n		for (int j = BORDER_DEPTH; j < BOARD_LENGTH-BORDER_DEPTH; j++) {\n			char neg = board_state[i][j] < 0 ? 'W' : board_state[i][j] > 0 ? 'B' : ' ';\n			cout << neg << humanReadablePieces[abs(board_state[i][j])] << \"|\";\n		}\n		cout << endl;\n	}\n	cout << \"  ----------------------- \" << endl;\n	cout << \"   a  b  c  d  e  f  g  h \" << endl << endl;\n}\n",
			"file": "src/chess_board.cpp",
			"file_size": 9187,
			"file_write_time": 130920570770736887,
			"settings":
			{
				"buffer_size": 9219,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Makefile",
			"settings":
			{
				"buffer_size": 533,
				"line_ending": "Unix"
			}
		},
		{
			"file": "README.md",
			"settings":
			{
				"buffer_size": 253,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/piece.cpp",
			"settings":
			{
				"buffer_size": 4080,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "diff --git a/src/piece.cpp b/src/piece.cpp\nindex 6fb75cd..8bc34b1 100644\n--- a/src/piece.cpp\n+++ b/src/piece.cpp\n@@ -1,17 +1,23 @@\n #include \"piece.h\"\n-#define CAN_PLACE_PIECE(a,b) (board_state[a][b] * team < 0 && board_state[a][b] != Types::INVALID)\n+#define CAN_PLACE_PIECE(a,b) (board_state[a][b] * team <= 0 && board_state[a][b] != Types::INVALID)\n #define ADD_MOVE(list, a, b) if (CAN_PLACE_PIECE(a,b)) list.push_back(std::make_pair(a,b));\n \n // All COORDS here are in real coords (1-12)\n \n-Piece::Piece(PlayerPiece player_piece, int inRow, int inCol, int** board_state) {\n+Piece::Piece(PlayerPiece in_player_piece, int inRow, int inCol, int board_state[][BOARD_LENGTH]) {\n+	player_piece = in_player_piece;\n 	row = inRow;\n 	col = inCol;\n 	team = player_piece < 0 ? 1 : -1;\n 	generate_valid_moves(board_state);\n }\n \n-Piece::Piece(PlayerPiece player_piece, int inRow, int inCol) {\n+int Piece::get_team() {\n+	return team;\n+}\n+\n+Piece::Piece(PlayerPiece in_player_piece, int inRow, int inCol) {\n+	player_piece = in_player_piece;\n 	row = inRow;\n 	col = inCol;\n 	team = player_piece < 0 ? 1 : -1;\n@@ -21,7 +27,7 @@ std::pair<int,int> Piece::get_coords() {\n 	return std::make_pair(row, col);\n }\n \n-void Piece::move(int inRow, int inCol, int** board_state) {\n+void Piece::move(int inRow, int inCol, int board_state[][BOARD_LENGTH]) {\n 	row = inRow;\n 	col = inCol;\n 	generate_valid_moves(board_state);\n@@ -35,12 +41,21 @@ std::vector<std::pair<int,int>> Piece::get_valid_moves() {\n 	return valid_moves;\n }\n \n-void Piece::generate_valid_moves(int** board_state) {\n+void Piece::generate_valid_moves(int board_state[][BOARD_LENGTH]) {\n 	int i;\n-	switch (typeOf()) {\n+	Types type = typeOf();\n+	switch (type) {\n 		case PAWN:\n+			// Can only move if no piece\n+			if (board_state[row+1 * team, col] == Types::EMPTY)\n 			ADD_MOVE(valid_moves, row + 1 * team, col);\n+			if (board_state[row+1 * team, col] == Types::EMPTY)\n 			ADD_MOVE(valid_moves, row + 2 * team, col);\n+			// Can attack diagonally, if there is a piece present\n+			if (board_state[row+1*team, col+1] * team < 0 && board_state[a][b] != Types::INVALID)\n+				ADD_MOVE(valid_moves, row + 1 * team, col + 1);\n+			if (board_state[row+1*team, col-1] * team < 0 && board_state[a][b] != Types::INVALID)\n+				ADD_MOVE(valid_moves, row + 1 * team, col - 1);\n 			break;\n 		case QUEEN:\n 		case ROOK:\n@@ -117,6 +132,8 @@ void Piece::generate_valid_moves(int** board_state) {\n 			ADD_MOVE(valid_moves, row + 1, col-1);\n 			ADD_MOVE(valid_moves, row + 1, col);\n 			break;\n+		default:\n+			break;\n 	}\n }\n \n",
			"settings":
			{
				"buffer_size": 2542,
				"line_ending": "Unix",
				"name": "Git Diff",
				"read_only": true,
				"scratch": true
			}
		}
	],
	"build_system": "Packages/User/AIProj.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/C++/C++ Single File.sublime-build",
					""
				],
				[
					"Packages/C++/C++ Single File.sublime-build",
					"Run"
				],
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				],
				[
					"Packages/User/AIProj.sublime-build",
					""
				]
			],
			[
				"Packages/User/AIProj.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				]
			],
			[
				"Packages/Makefile/Make.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				],
				[
					"Packages/User/AIProj.sublime-build",
					""
				]
			],
			[
				"Packages/User/AIProj.sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 117.0,
		"last_filter": "push",
		"selected_items":
		[
			[
				"push",
				"Git: Push"
			],
			[
				"comm",
				"Git: Commit"
			],
			[
				"add",
				"Git: Add..."
			],
			[
				"status",
				"Git: Status"
			],
			[
				"com",
				"Git: Commit"
			],
			[
				"git",
				"Git: Status"
			],
			[
				"git ",
				"Git: Custom Command"
			],
			[
				"git c",
				"Git: Commit"
			],
			[
				"git add",
				"Git: Add..."
			],
			[
				"git com",
				"Git: Commit"
			],
			[
				"gitadd",
				"Git: Diff Staged Files"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"packa",
				"Package Control: Disable Package"
			],
			[
				"",
				"Package Control: Enable Package"
			],
			[
				"package",
				"Package Control: Add Repository"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 139.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/akul/Documents/HKU/AI/Project",
		"/home/akul/Documents/HKU/AI/Project/src",
		"/home/akul/Documents/HKU/AI/Project/src/header"
	],
	"file_history":
	[
		"/home/akul/Documents/HKU/AI/Project/AIProject.sublime-project",
		"/home/akul/Documents/HKU/AI/Project/src/main.cpp",
		"/home/akul/Documents/HKU/AI/Project/Makefile",
		"/home/akul/Documents/HKU/AI/Project/.gitignore",
		"/home/akul/Documents/HKU/AI/Project/src/chess_board.cpp",
		"/home/akul/Documents/HKU/AI/Project/AIProject",
		"/home/akul/Documents/HKU/AI/Project/README.md",
		"/home/akul/Documents/HKU/AI/Project/src/header/pieces.h",
		"/home/akul/Documents/HKU/AI/Project/AIProj.sublime-build",
		"/home/akul/.config/sublime-text-3/Packages/User/AIProj.sublime-build",
		"/home/akul/Documents/HKU/AI/HW2/BruteForceP1.py",
		"/home/akul/Documents/HKU/AI/HW2/test.key"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"pragma",
			"generate",
			"EMPTY",
			")\n",
			"col",
			"Col",
			"White",
			"Piece.",
			"BLACK",
			"WHITE",
			"row",
			"}\n",
			"WHITE",
			"White"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": true,
		"regex": false,
		"replace_history":
		[
			"NONE",
			"Black",
			"Piece::",
			"Piece.BLACK",
			"Piece.WHITE",
			"col",
			"BLACK",
			"Black",
			"// White Pawns:\n	for (int i = 0; i < CHESS_PLAY_LENGTH; i++) {\n		board_state[B][i+BORDER_DEPTH] = WHITE_PAWN;\n	}\n\n	//White Rooks\n	board_state[A][BORDER_DEPTH] = WHITE_ROOK;\n	board_state[A][BORDER_DEPTH+CHESS_PLAY_LENGTH-1] = WHITE_ROOK;\n\n	//White Knights\n	board_state[A][BORDER_DEPTH+1] = WHITE_KNIGHT;\n	board_state[A][BORDER_DEPTH+CHESS_PLAY_LENGTH-2] = WHITE_KNIGHT;\n\n	//White Bishops\n	board_state[A][BORDER_DEPTH+2] = WHITE_BISHOP;\n	board_state[A][BORDER_DEPTH+CHESS_PLAY_LENGTH-3] = WHITE_BISHOP;\n\n	//White King\n	board_state[A][BORDER_DEPTH+3] = WHITE_KING;\n	//White Queen\n	board_state[A][BORDER_DEPTH+CHESS_PLAY_LENGTH-4] = WHITE_QUEEN;"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": false
	},
	"groups":
	[
		{
			"selected": 3,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/header/chess_board.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1919,
						"regions":
						{
						},
						"selection":
						[
							[
								887,
								887
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 578.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/header/piece.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1159,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": -0.0,
						"translation.y": 153.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/main.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 505,
						"regions":
						{
						},
						"selection":
						[
							[
								63,
								63
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 51.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/chess_board.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9219,
						"regions":
						{
						},
						"selection":
						[
							[
								652,
								652
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 357.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "Makefile",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 533,
						"regions":
						{
						},
						"selection":
						[
							[
								151,
								151
							]
						],
						"settings":
						{
							"syntax": "Packages/Makefile/Makefile.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "README.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 253,
						"regions":
						{
						},
						"selection":
						[
							[
								124,
								124
							]
						],
						"settings":
						{
							"syntax": "Packages/Markdown/Markdown.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "src/piece.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4080,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 7,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2542,
						"regions":
						{
						},
						"selection":
						[
							[
								2542,
								2542
							]
						],
						"settings":
						{
							"syntax": "Packages/Diff/Diff.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 25.0
	},
	"input":
	{
		"height": 33.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 191.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.git":
	{
		"height": 112.0
	},
	"pinned_build_system": "Build Debug and Run",
	"project": "AIProject.sublime-project",
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
